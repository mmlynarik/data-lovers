import os
import logging
from datetime import datetime
from collections import namedtuple, OrderedDict

import openpyxl as xls
import pandas as pd
from textdistance import levenshtein, jaro_winkler


logging.basicConfig(level=logging.DEBUG)


class BusinessTermsMapping:
    """Automatic mapping of data model business terms onto database data fields.

    Uses edit-based algorithms from `textdistance` library to calculate for each
    business term its respective distance to each of data fields. The most common
    algorithm used for this kind of task is `levenshtein`.

    Parameters
    ----------
    data_dir : str
        Path to directory where input csv files are stored. Use naming convention
        business_terms.csv for business terms and data_fields.csv for data fields.
        Further conditions on naming convention of columns in sheets apply as well:
        business_terms.csv must contain columns `entity` and `attribute`, while
        data_fields.csv must contain columns `data_field` and `data_structure`.
    ncandidates : int, optional
        Number of candidates generated by the mapping algorithms
    name : str, optional
        Name of the mapping, e.g. name of the dataset

    Attributes
    ----------
    data : namedtuple
        Data storage for business_terms and data_fields DataFrames.
    mapping_candidates : dict
        A dictionary of mapping candidates for data fields
    feasible_algorithms : list of str
        List of feasible algorithms used for finding edit-based distances
    algorithm : str
        Algorithm most recently used for finding mapping candidates using
        edit-based distances

    See Also
    --------
    https://demo.glossary.accurity.ai/ui/?list=subjectArea

    """
    def __init__(self, data_dir, name=None, ncandidates=5):
        self.data_dir = data_dir
        self.name = name
        self.ncandidates = ncandidates
        self.log = logging.getLogger(name)
        self.feasible_algorithms = [
            'Hamming', 'MLIPNS', 'Levenshtein',
            'DamerauLevenshtein', 'Jaro', 'JaroWinkler',
            'StrCmp95', 'NeedlemanWunsch', 'Gotoh', 'SmithWaterman',
        ]

    def __repr__(self):
        return f"""FieldsBusinessTermsMap(
            data_dir={self.data_dir},
            last_algorithm={self.algorithm.__class__.__name__})"""

    def load_data(self):
        """Load data from csv files and store them into DataFrames."""
        Datasets = namedtuple("Datasets", ["business_terms", "data_fields"])
        path_bt = os.path.join(self.data_dir, "business_terms.csv")
        path_df = os.path.join(self.data_dir, "data_fields.csv")

        if os.path.exists(path_bt) and os.path.exists(path_df):
            business_terms = pd.read_csv(path_bt)
            data_fields = pd.read_csv(path_df)
            self.data = Datasets(business_terms, data_fields)
        else:
            raise Exception("""Data directory does not contain required csv files.
                               Please check the class docstring for more information.""")

    def find_mapping(self, algorithm):
        """Calculate mapping candidates for each data field w.r.t the business terms.

        This method will calculate distances between data fields and business terms and
        for each data field will store only `ncandidate` number of mapping candidates.

        Parameters
        ----------
        algorithm : algorithm instance from textdistance library
            Callable class instance from textdistance library calculating distance between
            data fields and business terms.

        Returns
        -------
        self.mapping_candidates : dict
            A dictionary of mapping candidates
        """
        algo = algorithm.__class__.__name__
        if algo not in self.feasible_algorithms:
            raise Exception(f"{algo} is not among feasible distance algorithms.")

        business_terms = (
            self.data.business_terms.entity.str.replace(' ', '_') + '.'
            + self.data.business_terms.attribute.str.replace(' ', '_')
        ).str.lower().drop_duplicates()

        data_fields = (
            self.data.data_fields.data_structure + '.'
            + self.data.data_fields.data_field
        ).str.lower().drop_duplicates()

        self.mapping_candidates = {}
        sign = -1 if algorithm == jaro_winkler else 1

        start_time = datetime.now()
        self.log.info(f"Start calculating mappings using {algo}: {start_time.strftime('%X')}")
        for data_field in data_fields:
            distances = []
            for business_term in business_terms:
                distance = round(algorithm(s1=data_field, s2=business_term), 2)
                distances.append((business_term, distance))
            distances = sorted(distances, key=lambda x: sign * x[1])
            self.mapping_candidates[data_field] = distances[:self.ncandidates]

        self.algorithm = algorithm
        self.log.info(f'Finished mappings for data_fields in {datetime.now() - start_time}')

    @staticmethod
    def prepare_sheet_to_append(fpath, sheet):
        """Create workbook or delete the sheet in existing workbook."""
        if not os.path.exists(fpath):
            print(f'{fpath} file does not exist. It will be created first.')
            wb = xls.Workbook()
            wb.save(filename=fpath)
            return

        wb = xls.load_workbook(fpath)
        if sheet in wb.sheetnames:
            print(f'{sheet} sheet exists in {fpath}. It will be deleted first.')
            wb.remove(wb[sheet])
            wb.save(fpath)

    def export_mapping_to_xls(self, fname='mapping_candidates.xlsx'):
        """Export mapping candidates to excel file in the `self.data_dir` directory."""
        fpath = os.path.join(self.data_dir, fname)
        try:
            algo = self.algorithm.__class__.__name__
        except AttributeError:
            raise Exception("Mapping does not exist. Run find_mapping_candidates() first.")

        BusinessTermsMapping.prepare_sheet_to_append(fpath, algo)

        col_names = ['business_term_' + str(i) for i in range(1, self.ncandidates + 1)]
        data_fields = pd.Series(data=self.mapping_candidates.keys(), name='data_field')
        candidates = pd.DataFrame(data=self.mapping_candidates.values(), columns=col_names)
        result = pd.concat([data_fields, candidates], axis=1)

        with pd.ExcelWriter(fpath, engine='openpyxl', mode='a') as writer:
            result.to_excel(writer, sheet_name=algo, index=False)
